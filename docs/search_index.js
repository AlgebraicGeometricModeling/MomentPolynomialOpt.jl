var documenterSearchIndex = {"docs":
[{"location":"code/3.polynomials/#Polynomials","page":"Polynomials","title":"Polynomials","text":"","category":"section"},{"location":"code/3.polynomials/","page":"Polynomials","title":"Polynomials","text":"Pages = [\"3.polynomials.md\"]","category":"page"},{"location":"code/3.polynomials/","page":"Polynomials","title":"Polynomials","text":"polar_ideal","category":"page"},{"location":"code/3.polynomials/#MomentTools.polar_ideal","page":"Polynomials","title":"MomentTools.polar_ideal","text":"j = polar_ideal(f, [h1, h2, ...], [g1, g2, ...], X)\n\nCompute generators of the polar ideal associated with f, [h1, h2, ...], [g1, g2, ...] (equality constraints hi == 0 and the sign constraints gi >= 0) with respect to the variable vector X.\n\nf, hi, gi should be polynomials in variables X.\n\n\n\n\n\n","category":"function"},{"location":"code/3.polynomials/","page":"Polynomials","title":"Polynomials","text":"preordering","category":"page"},{"location":"code/3.polynomials/#MomentTools.preordering","page":"Polynomials","title":"MomentTools.preordering","text":"pg = preordering([g1, g2, ...])\n\nCompute all the product, without repetitions, of the gi's i.e. computes the generators (as a quadratic module) of the preordering O(g1, g2, ...).\n\n\n\n\n\n","category":"function"},{"location":"expl/2.positive_polynomial/#The-minimizers-of-Motzkin-polynomial","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"","category":"section"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"using DynamicPolynomials, MomentTools, Plots;\nusing JuMP, MosekTools; mmt_optimizer(JuMP.optimizer_with_attributes(Mosek.Optimizer, \"QUIET\" => true));","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"\u001b[36m\u001b[1m[ \u001b[22m\u001b[39m\u001b[36m\u001b[1mInfo: \u001b[22m\u001b[39mPrecompiling MomentTools [65cd4d85-9fe5-4fdc-93e2-c8798c615752]","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"We use Mosek solver for the convex optimization on SDP matrices.","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"X  = @polyvar x y\nmotz = x^4*y^2 + x^2*y^4 - 3x^2*y^2  + 1 ","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"$ x^{4}y^{2} + x^{2}y^{4} - 3x^{2}y^{2} + 1 $","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"This polynomial, known as Motzkin polynomial, is non-negative but not a sum of squares.","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"We construction a moment relaxation of order 6, imposing the moments to come from a probability measure, with total mass equal to 1:","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"v, M = minimize(motz,[],[],X,6)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"(-4.8872999936298315e-9, A JuMP Model\nMinimization problem with:\nVariables: 91\nObjective function type: AffExpr\n`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\n`Vector{AffExpr}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: basis, degree, dual, index, moments, monomials, nu, type, variables, y)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"v","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"-4.8872999936298315e-9","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"The objective value is a lower bound of the actual mimimal value 0 of Motzkin polynomial.","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"We extract a measure from the sequence of moments, using the function MultivariateSeries.decompose:","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"w, Xi = get_measure(M)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"(Float64[], Matrix{Float64}(undef, 2, 0))","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"w is the vector of weights and Xi is the matrix of points, that is support of the measure mu=sum_i omega_i delta_Xi_i. w[i] is the weight of the Dirac measure corresponding to the point Xi[:,i] in this decomposition.","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"Here no point is found to approximate the optimal moment sequence.","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"Now, to find the minimizers, we add as constraints, that the gradient of the polynomial should vanish:","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"J = differentiate(motz,X)\nv, M = minimize(motz, J,[], X, 6)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"(3.508005206489722e-8, A JuMP Model\nMinimization problem with:\nVariables: 91\nObjective function type: AffExpr\n`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 73 constraints\n`Vector{AffExpr}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: basis, degree, dual, index, moments, monomials, nu, type, variables, y)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"w, Xi = get_measure(M)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"(ComplexF64[0.2500002557692951 + 2.459699184908756e-20im, 0.24999971826800954 + 2.4632532654063837e-20im, 0.24999971826800496 - 4.621500317393238e-21im, 0.2500002557692956 - 7.901166120055862e-21im], ComplexF64[-1.0000002769852416 + 7.235664138030071e-18im -0.9998885652371537 - 2.2816957101921287e-16im 0.9998885652371393 - 5.600102269268173e-17im 1.0000002769852419 + 1.9005703668204767e-18im; -1.000000223683219 - 7.962988840975802e-18im 0.9998649220849618 + 2.5110504204834785e-16im -0.9998649220849452 + 6.163021254372132e-17im 1.0000002236832188 - 2.0916145820580463e-18im])","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"p0 = plot([-1,-1,1,1], [-1,1,-1,1], seriestype = :scatter, color=:blue, fmt=:png)\np1 = plot!(p0,real(Xi[1,:]), real(Xi[2,:]), seriestype = :scatter, zcolor = abs.(w), m = (:heat, 0.8, Plots.stroke(1, :black)), fmt=:png)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"(Image: png)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"We find approximately the 4 minimizers.","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"Finally, to find the minimizers, we try another strategy and add the constraint that the polynomial should vanish, since we know that its minimal value (at the minimizers) is 0:","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"v, M = minimize(motz, [motz], [], X, 6)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"(6.36075870781102e-9, A JuMP Model\nMinimization problem with:\nVariables: 91\nObjective function type: AffExpr\n`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 29 constraints\n`Vector{AffExpr}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: basis, degree, dual, index, moments, monomials, nu, type, variables, y)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"w, Xi = get_measure(M)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"([0.25002760879847424, 0.24997227997064125, 0.24997227997064245, 0.2500276087984727], [0.9999940087362019 -0.9999111310550343 0.9999111310550342 -0.999994008736202; 1.000026692417085 1.0000196501600218 -1.0000196501600218 -1.0000266924170849])","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"p0 = plot([-1,-1,1,1], [-1,1,-1,1], seriestype = :scatter, color=:blue, fmt=:png)\np1 = plot!(p0,real(Xi[1,:]), real(Xi[2,:]), seriestype = :scatter, zcolor = abs.(w), m = (:heat, 0.8, Plots.stroke(1, :black)), fmt=:png)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"(Image: png)","category":"page"},{"location":"expl/2.positive_polynomial/","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"The minimizers (in red) are close to that actual minimizers (in blue).","category":"page"},{"location":"expl/1.maximizers/#Solving-a-polynomial-optimization-problem","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"","category":"section"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"using DynamicPolynomials, MomentTools","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"X  = @polyvar x1 x2\n\ne1 = x1^2-2\ne2 = (x2^2-3)*(x1*x2-2)\n\np1 = x1\np2 = 2-x2;","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"We are looking for the points with maximal x_1 in the set e_1=e_2=0 such that p_1geq 0, p_2geq 0. ","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"We solve a SDP relaxation of order d=4, where the variables of the underlying convex optimization problem are the moments of order le 2d in the variables x_1 x_2.","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"using CSDP;\nv, M = maximize(x1, [e1, e2], [p1,p2], X, 4,CSDP.Optimizer)\nv","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"The output of the function maximize is the optimal value v and the optimization model M. ","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"The points which reach the optimal value, can be obtained as follows: ","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"Xi = get_minimizers(M)","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"Each column of this matrix represents a point. It is an ntimes r  matrix, where n is the number of coordinates in X and r is the number of points.","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"The weighted sum of Dirac measures associated to the optimal moment sequence can be obtained as follows:","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"w, Xi = get_measure(M)","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"w is the vector of weights and Xi is the matrix of points, that is support of the measure mu=sum_i omega_i delta_Xi_i.","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"Here is another way to solve it. We describe it as a Polynomial Optimization Problem and use the function optimize:","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"pop = [(x1, \"sup\"), (e1,\"=0\"),(e2 ,\"=0\"),(p1,\">=0\"),(p2,\">=0\")]","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"v, M = optimize(pop, X, 4, CSDP.Optimizer)","category":"page"},{"location":"expl/1.maximizers/","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"get_minimizers(M)","category":"page"},{"location":"code/1.moment_model/#Moment-Program","page":"Moment Program","title":"Moment Program","text":"","category":"section"},{"location":"code/1.moment_model/","page":"Moment Program","title":"Moment Program","text":"Pages = [\"1.moment_model.md\"]","category":"page"},{"location":"code/1.moment_model/","page":"Moment Program","title":"Moment Program","text":"MOM.Model","category":"page"},{"location":"code/1.moment_model/#MomentTools.MOM.Model","page":"Moment Program","title":"MomentTools.MOM.Model","text":"Construct the Moment Program in the variables X of order d. The moments of all monomials in X of degree 2*d are variables of the optimization program.\n\nM = MOM.Model(X,d, optimizer=MMT[:optimizer]; nu=k)\n\nX is the vector of variables\nd is the order of the moment relaxation\n'optimizer`is the the optimizer used to solve the SDP program\nnu=k is the number of Positive Moment Sequences\n\n\n\n\n\nM = MOM.Model( `sense`, f, [e1, e2, ...], [g1, g2, ...], X, d)\n\nConstruct the Moment Program in the variables X of order d.\n\nsense == \"inf\" or \"sup\"\nf polynomial objective function\n[e1, e2, ...] array of polynomial equality constraints (can be empty)\n[g1, g2, ...] array of non-negativity constraints (can be empty)\nX is the vector of variables\nd is the order of the moment relaxation.\n\n\n\n\n\nM = MOM.Model(C, X, d)\n\nConstruct the Moment Program where\n\nC is a vector of pairs (f, sense ) of objective or constraints where f is a polynomial and sense is \"inf\", \"min\", \"sup\", \"max\", \">=0\", \"<=0\", \"=0\", or an interval \nX is the vector of variables\nd is the order of the moment relaxation.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/","page":"Moment Program","title":"Moment Program","text":"MOM.MomentModel","category":"page"},{"location":"code/1.moment_model/#MomentTools.MOM.MomentModel","page":"Moment Program","title":"MomentTools.MOM.MomentModel","text":"Construct the Moment Program in the variables X of order d. The moments of all monomials in X of degree 2*d are variables of the optimization program.\n\nM = MomentModel(X,d; nu=k)\n\nX is the vector of variables\nd is the order of the moment relaxation.\nnu=k is the number of Positive Moment Sequences\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/#Constraints","page":"Moment Program","title":"Constraints","text":"","category":"section"},{"location":"code/1.moment_model/","page":"Moment Program","title":"Moment Program","text":"MOM.constraint_zero","category":"page"},{"location":"code/1.moment_model/#MomentTools.MOM.constraint_zero","page":"Moment Program","title":"MomentTools.MOM.constraint_zero","text":"constraint_zero(M, eqs ...)\n\nAdd to the moment program M, the constraints e star mu_i = 0 for i in 1:M[:nu] and e in eqs.\n\n\n\n\n\nconstraint_zero(M, i::Int, eqs ...)\n\nAdd to the moment program M, the constraint e star mu_i = 0 for e in eqs.\n\n\n\n\n\nconstraint_zero(M, Eqs ...)\n\nAdd to the moment program M, the constraints sum_i=1^nu mathbfe_i star mu_i =0  for mathbfe in Eqs where Eqs is a sequence of vectors of nu=M[:nu] polynomials.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/","page":"Moment Program","title":"Moment Program","text":"MOM.constraint_nneg","category":"page"},{"location":"code/1.moment_model/#MomentTools.MOM.constraint_nneg","page":"Moment Program","title":"MomentTools.MOM.constraint_nneg","text":"constraint_nneg(M, eqs ...)\n\nAdd to the moment program M, the constraints e star mu_i succeq 0 for i in 1:M[:nu] and e in eqs.\n\n\n\n\n\nconstraint_nneg(M, i::Int64, eqs ...)\n\nAdd to the moment program M, the constraints e star mu_i succeq 0 for  e in eqs.\n\n\n\n\n\nconstraint_nneg(M, Eqs ...)\n\nAdd to the moment program M, the constraints sum_i=1^nu mathbfe_i star mu_i succeq 0  for mathbfe in Eqs where Eqs is a sequence of vectors of nu=M[:nu] polynomials.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/","page":"Moment Program","title":"Moment Program","text":"MOM.constraint_moments","category":"page"},{"location":"code/1.moment_model/#MomentTools.MOM.constraint_moments","page":"Moment Program","title":"MomentTools.MOM.constraint_moments","text":"constraint_moments(M, [m => c, ...])\n\nAdd to the moment program M, the constraints langle mu_i m rangle - c = 0  for i in 1:M[:nu] and all pairs m=>c.\n\n\n\n\n\nconstraint_moments(M, [m => c, ...], p)\n\nAdd to the moment program M, the constraints sum_i=1^nulangle p_i star mu_i mrangle - c = 0  for all pairs m=>c, where p is a vector of nu=M[:nu] polynomials.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/","page":"Moment Program","title":"Moment Program","text":"MOM.constraint_unitmass","category":"page"},{"location":"code/1.moment_model/#MomentTools.MOM.constraint_unitmass","page":"Moment Program","title":"MomentTools.MOM.constraint_unitmass","text":"constraint_unitmass(M, i::Int64, p)\n\nAdd to the moment program M, the constraints langle p star mu_i 1 rangle - 1 = 0 where p is a polynomial.\n\n\n\n\n\nconstraint_unitmass(M, p)\n\nAdd to the moment program M, the constraints langle p_i star mu_i 1 rangle - 1 = 0 where p is a vector of nu=M[:nu] polynomials.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/#Objective-function","page":"Moment Program","title":"Objective function","text":"","category":"section"},{"location":"code/1.moment_model/","page":"Moment Program","title":"Moment Program","text":"MOM.set_objective","category":"page"},{"location":"code/1.moment_model/#MomentTools.MOM.set_objective","page":"Moment Program","title":"MomentTools.MOM.set_objective","text":"set_objective(M, sense, p)\n\nSet the \"inf\" or \"sup\" objective function to  sum_i=1^nu langle pstar mu_i 1 rangle where p is a polynomial.\n\n\n\n\n\nset_objective(M, sense, p)\n\nSet the \"inf\" or \"sup\" objective function to  sum_i=1^nu langle p_i star mu_i 1 rangle where p is a vector of nu=M[:nu] polynomials. \n\n\n\n\n\nset_objective(M, sense, i, p)\n\nSet the \"inf\" or \"sup\" objective function to  langle p star mu_i 1 rangle where p is a polynomial. \n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/","page":"Moment Program","title":"Moment Program","text":"MOM.set_objective_tv","category":"page"},{"location":"code/1.moment_model/#MomentTools.MOM.set_objective_tv","page":"Moment Program","title":"MomentTools.MOM.set_objective_tv","text":"set_objective_ncl(M)\n\nSet the objective function of moment program to the total variation of the moment sequences mu_i, that is  the sum  of the unit mass of the positive moment sequences sum_i=1^nu langle mu_i 1rangle.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/","page":"Moment Program","title":"Moment Program","text":"MOM.set_objective_ncl","category":"page"},{"location":"code/1.moment_model/#MomentTools.MOM.set_objective_ncl","page":"Moment Program","title":"MomentTools.MOM.set_objective_ncl","text":"set_objective_ncl(M)\n\nSet the objective function of moment program to the nuclear norm or equivalently the sum of  the traces of the moment matrices.\n\n\n\n\n\n","category":"function"},{"location":"package/#About-MomentTools.jl","page":"About the package","title":"About MomentTools.jl","text":"","category":"section"},{"location":"package/#Dependencies","page":"About the package","title":"Dependencies","text":"","category":"section"},{"location":"package/","page":"About the package","title":"About the package","text":"A version of Julia >= 1.3 should be used.","category":"page"},{"location":"package/","page":"About the package","title":"About the package","text":"It depends on the following packages, which are installed automatically:","category":"page"},{"location":"package/","page":"About the package","title":"About the package","text":"Combinatorics for the computation of polar ideals.\nDualization for the use of dual optimization solvers on the moment optimization problems.\nDynamicPolynomials \nJuMP\nLinearAlgebra\nMultivariateSeries (v>=1.1.2) for the representation of moment sequences and the decomposition of series.","category":"page"},{"location":"package/","page":"About the package","title":"About the package","text":"To solve the moment optimization problems, SDP optimizers have also to be installed, such as MosekTools, CSD, ...","category":"page"},{"location":"package/#Development","page":"About the package","title":"Development","text":"","category":"section"},{"location":"package/","page":"About the package","title":"About the package","text":"The git project of the package is     https://github.com/AlgebraicGeometricModeling/MomentTools.jl.","category":"page"},{"location":"package/","page":"About the package","title":"About the package","text":"The main developpers are (so far)","category":"page"},{"location":"package/","page":"About the package","title":"About the package","text":"Lorenzo Baldi\nBernard Mourrain","category":"page"},{"location":"package/","page":"About the package","title":"About the package","text":"The development is done in relation with the activity of the network POEMA.","category":"page"},{"location":"package/#See-also","page":"About the package","title":"See also","text":"","category":"section"},{"location":"package/","page":"About the package","title":"About the package","text":"Other Julia packages are currently developed for polynomial and moment optimization:","category":"page"},{"location":"package/","page":"About the package","title":"About the package","text":"MomentOpt\nSumOfSquares\nPolyJuMP","category":"page"},{"location":"expl/3.positive_moment_sequences/#Constraints-on-Positive-Moment-Sequences","page":"Constraints on Positive Moment Sequences","title":"Constraints on Positive Moment Sequences","text":"","category":"section"},{"location":"expl/3.positive_moment_sequences/","page":"Constraints on Positive Moment Sequences","title":"Constraints on Positive Moment Sequences","text":"using DynamicPolynomials, MultivariateSeries, MomentTools\nusing MosekTools; optimizer = Mosek.Optimizer;","category":"page"},{"location":"expl/3.positive_moment_sequences/","page":"Constraints on Positive Moment Sequences","title":"Constraints on Positive Moment Sequences","text":"┌ Info: Precompiling MomentTools [65cd4d85-9fe5-4fdc-93e2-c8798c615752]\n└ @ Base loading.jl:1273\n┌ Warning: Package MomentTools does not have MultivariateSeries in its dependencies:\n│ - If you have MomentTools checked out for development and have\n│   added MultivariateSeries as a dependency but haven't updated your primary\n│   environment's manifest file, try `Pkg.resolve()`.\n│ - Otherwise you may need to report an issue with MomentTools\n└ Loading MultivariateSeries into MomentTools from project dependency, future warnings for MomentTools are suppressed.","category":"page"},{"location":"expl/3.positive_moment_sequences/","page":"Constraints on Positive Moment Sequences","title":"Constraints on Positive Moment Sequences","text":"X = @polyvar x y\nd = 10\nM  = MomentModel(X, d, optimizer, nu=2)","category":"page"},{"location":"expl/3.positive_moment_sequences/","page":"Constraints on Positive Moment Sequences","title":"Constraints on Positive Moment Sequences","text":"A Moment program with:\nA JuMP Model\nFeasibility problem with:\nVariables: 462\n`Array{JuMP.VariableRef,1}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 2 constraints\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: Dual model with Mosek attached\nNames registered in the model: basis, degree, dual, index, moments, monomials, nu, variables, y","category":"page"},{"location":"expl/3.positive_moment_sequences/","page":"Constraints on Positive Moment Sequences","title":"Constraints on Positive Moment Sequences","text":"constraint_nneg(M,1, 1-x^2-y^2)\nconstraint_nneg(M,2, 1-x^2, 1-y^2)","category":"page"},{"location":"expl/3.positive_moment_sequences/","page":"Constraints on Positive Moment Sequences","title":"Constraints on Positive Moment Sequences","text":"L = monomials(X, seq(0:2*d))\nlebesgue(i,j) = ((1-(-1)^(i+1))/(i+1))*((1-(-1)^(j+1))/(j+1))\nconstraint_moments(M,\n                   [(m=>lebesgue(exponents(m)...)) for m in L],\n                   collect(1:2), [1,1] )","category":"page"},{"location":"expl/3.positive_moment_sequences/","page":"Constraints on Positive Moment Sequences","title":"Constraints on Positive Moment Sequences","text":"objective(M, 1, 1.0, \"sup\")","category":"page"},{"location":"expl/3.positive_moment_sequences/","page":"Constraints on Positive Moment Sequences","title":"Constraints on Positive Moment Sequences","text":"$ y_{1,1} $","category":"page"},{"location":"expl/3.positive_moment_sequences/","page":"Constraints on Positive Moment Sequences","title":"Constraints on Positive Moment Sequences","text":"v = optimize(M)[1]","category":"page"},{"location":"expl/3.positive_moment_sequences/","page":"Constraints on Positive Moment Sequences","title":"Constraints on Positive Moment Sequences","text":"Problem\n  Name                   :                 \n  Objective sense        : min             \n  Type                   : CONIC (conic optimization problem)\n  Constraints            : 462             \n  Cones                  : 0               \n  Scalar variables       : 231             \n  Matrix variables       : 5               \n  Integer variables      : 0               \n\nOptimizer started.\nPresolve started.\nLinear dependency checker started.\nLinear dependency checker terminated.\nEliminator started.\nFreed constraints in eliminator : 0\nEliminator terminated.\nEliminator started.\nFreed constraints in eliminator : 0\nEliminator terminated.\nEliminator - tries                  : 2                 time                   : 0.00            \nLin. dep.  - tries                  : 1                 time                   : 0.00            \nLin. dep.  - number                 : 0               \nPresolve terminated. Time: 0.00    \nProblem\n  Name                   :                 \n  Objective sense        : min             \n  Type                   : CONIC (conic optimization problem)\n  Constraints            : 462             \n  Cones                  : 0               \n  Scalar variables       : 231             \n  Matrix variables       : 5               \n  Integer variables      : 0               \n\nOptimizer  - threads                : 8               \nOptimizer  - solved problem         : the primal      \nOptimizer  - Constraints            : 462\nOptimizer  - Cones                  : 1\nOptimizer  - Scalar variables       : 232               conic                  : 232             \nOptimizer  - Semi-definite variables: 5                 scalarized             : 7527            \nFactor     - setup time             : 0.01              dense det. time        : 0.00            \nFactor     - ML order time          : 0.00              GP order time          : 0.00            \nFactor     - nonzeros before factor : 5.43e+04          after factor           : 8.74e+04        \nFactor     - dense dim.             : 2                 flops                  : 5.44e+07        \nITE PFEAS    DFEAS    GFEAS    PRSTATUS   POBJ              DOBJ              MU       TIME  \n0   3.0e+00  4.0e+00  1.0e+00  0.00e+00   0.000000000e+00   0.000000000e+00   1.0e+00  0.02  \n1   8.6e-01  1.1e+00  7.4e-02  3.19e-01   2.227313818e+00   2.034785147e+00   2.9e-01  0.03  \n2   2.0e-01  2.7e-01  8.0e-03  1.62e+00   3.558535953e+00   3.532069682e+00   6.8e-02  0.05  \n3   5.3e-02  7.1e-02  1.1e-03  1.50e+00   3.775424594e+00   3.770494332e+00   1.8e-02  0.07  \n4   1.4e-02  1.9e-02  1.6e-04  1.01e+00   3.774265528e+00   3.773107456e+00   4.7e-03  0.09  \n5   4.9e-03  6.5e-03  4.0e-05  8.08e-01   3.760047982e+00   3.759705942e+00   1.6e-03  0.10  \n6   2.7e-03  3.6e-03  2.4e-05  3.66e-01   3.749815207e+00   3.749724302e+00   8.9e-04  0.12  \n7   6.9e-04  9.2e-04  4.9e-06  3.80e-01   3.725437924e+00   3.725569163e+00   2.3e-04  0.14  \n8   2.4e-04  3.1e-04  1.2e-06  3.25e-01   3.704778259e+00   3.704873452e+00   7.9e-05  0.17  \n9   1.1e-04  1.4e-04  5.3e-07  2.30e-01   3.691943416e+00   3.692063045e+00   3.6e-05  0.18  \n10  3.1e-05  4.1e-05  1.0e-07  4.47e-01   3.676385386e+00   3.676448347e+00   1.0e-05  0.20  \n11  1.1e-05  1.5e-05  3.2e-08  4.65e-01   3.668719992e+00   3.668774291e+00   3.7e-06  0.22  \n12  6.1e-06  8.2e-06  2.0e-08  2.94e-02   3.664551877e+00   3.664634224e+00   2.0e-06  0.24  \n13  3.2e-06  4.3e-06  1.2e-08  -1.56e-01  3.657723571e+00   3.657826546e+00   1.1e-06  0.26  \n14  1.1e-06  1.5e-06  3.4e-09  1.35e-01   3.645081107e+00   3.645162092e+00   3.6e-07  0.28  \n15  3.8e-07  4.9e-07  1.1e-09  1.24e-01   3.633102930e+00   3.633176735e+00   1.2e-07  0.29  \n16  2.3e-07  2.8e-07  6.8e-10  -1.62e-03  3.627183700e+00   3.627277402e+00   6.9e-08  0.31  \n17  9.2e-08  1.2e-07  2.8e-10  4.23e-02   3.615519444e+00   3.615608628e+00   2.9e-08  0.33  \n18  1.6e-08  2.9e-08  5.5e-11  1.94e-01   3.599258722e+00   3.599314907e+00   7.2e-09  0.35  \n19  5.8e-09  1.0e-08  1.5e-11  5.22e-01   3.591755197e+00   3.591786889e+00   2.6e-09  0.38  \n20  1.7e-09  3.0e-09  2.5e-12  7.78e-01   3.587479170e+00   3.587490742e+00   7.4e-10  0.41  \n21  7.7e-10  1.4e-09  9.0e-13  7.69e-01   3.586171166e+00   3.586178254e+00   3.4e-10  0.44  \n22  6.1e-10  8.9e-10  5.9e-13  5.74e-01   3.585752489e+00   3.585759466e+00   2.2e-10  0.47  \n23  3.7e-10  5.4e-10  3.2e-13  4.66e-01   3.585225807e+00   3.585231576e+00   1.3e-10  0.50  \n24  1.9e-10  2.7e-10  1.6e-13  2.65e-01   3.584589117e+00   3.584594599e+00   6.7e-11  0.53  \n25  1.9e-10  2.7e-10  1.6e-13  4.02e-01   3.584580797e+00   3.584586260e+00   6.7e-11  0.56  \n26  1.8e-10  2.5e-10  1.4e-13  3.99e-01   3.584512733e+00   3.584518052e+00   6.2e-11  0.60  \n27  8.7e-11  1.1e-10  5.5e-14  3.85e-01   3.583843540e+00   3.583847594e+00   2.7e-11  0.63  \n28  8.1e-11  8.4e-11  3.8e-14  3.28e-01   3.583633435e+00   3.583636690e+00   2.1e-11  0.65  \n29  7.9e-11  8.2e-11  3.7e-14  5.30e-01   3.583619139e+00   3.583622347e+00   2.1e-11  0.69  \n30  7.8e-11  8.2e-11  3.7e-14  6.05e-01   3.583618683e+00   3.583621889e+00   2.1e-11  0.73  \n31  7.8e-11  8.2e-11  3.7e-14  5.50e-01   3.583618683e+00   3.583621889e+00   2.1e-11  0.77  \n32  7.8e-11  8.2e-11  3.7e-14  5.60e-01   3.583618683e+00   3.583621889e+00   2.1e-11  0.82  \nOptimizer terminated. Time: 0.90    \n\n\n\n\n\n\n3.5836218894780534","category":"page"},{"location":"#Moment-Tools","page":"Home","title":"Moment Tools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package provide tools for solving polynomial and moment optimization problems on semi-algebraic sets defined by polynomial sign and equality constraints. In particular, it allows to optimize vectors of moments sequences that satisfy positivity constraints or mass constraints, It is based on Sum-of-Squares (SOS) and MoMent (MoM) convex relaxations, connected to Semi-Definite Programs (SDP) solvers. This a Julia package for solving polynomial optimization problems, via moment matrix relaxations.  Extraction tools allows to recover the global optimizers of the problem from optimal moment sequences, using flat truncation properties.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As an illustrative example, we consider the set S defined by the inequalities ","category":"page"},{"location":"","page":"Home","title":"Home","text":"leftbeginarrayl\nx^3 - y^2 ge 0\n1 - x^2 -y^2 ge 0\nendarray\nright","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is the blue domain below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: DomainCusp)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We want to maximize the objective function y^2 on this domain and to find the maximizer points. Here is how it can be done in MomentTools, with the SDP solver CSDP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MomentTools, DynamicPolynomials\nusing CSDP; MMT[:optimizer] = CSDP.Optimizer\n\nX = @polyvar x y\n\nG = [1 - x^2 - y^2, x^3-y^2 ]\n\nf = y^2\n\nv, M = maximize(f, [], G)\n\nw, Xi = get_measure(M)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This gives the following weigts and points of the weight sum of Dirac measures  associated to the optimal moment sequence. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nbeginarraycc\n04999999998860686  0499999999867594\nendarray\n\n\n\nbeginpmatrix\n07548776660872802  07548776660872801 \n06558656173161549  -06558656173161549 \nendpmatrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"These points, which are the maximizers of the optimization problem are the top and bottom \"corner\" points of the domain.","category":"page"},{"location":"#Optimization","page":"Home","title":"Optimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package allows to solve optimization problems on Pseudo Moment Sequences (PMS). A PMS is a sequence of values  mu=(mu_alpha) indexed by the monomial exponents alpha in mathbbN^n or equivalently a linear functional mu p in mathbbRmathbfx mapsto langle mu p rangle = sum_alpha p_alpha mu_alpha . It is positive if for all pin mathbbRmathbfx, we have   langle mu p^2 rangle geq 0 .","category":"page"},{"location":"","page":"Home","title":"Home","text":"Optimization problems of the following form are considered:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginarrayrl\nmathrminf_mu_i in PMS  sum_i langle f_istar mu_i 1 rangle \nst   sum_i g_ijstar mu_i succeq 0 quad j=1ldots n_1  \n       sum_i h_ijstar mu_i = 0 quad j=1ldots n_2\n       sum_i langle p_ijstar mu_i 1 rangle ge 0  quad j=1ldots n_3\n       sum_i langle q_ijstar mu_i 1 rangle = 0 quad j=1ldots n_4 \nendarray","category":"page"},{"location":"","page":"Home","title":"Home","text":"where","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu_i are positive PMS,\nf_i g_ij h_ij p_ij q_ij in mathbbRmathbfx are multivariate polynomials.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The solution of such optimization problem is approximated by the solution of a truncated relaxation of the problem, which is a convex optimization problem on Positive SemiDefinite matrices. Tools to construct such moment relaxation of a given order are available in the package.","category":"page"},{"location":"#Decomposition","page":"Home","title":"Decomposition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Decomposition tools are available to decompose or approximate a PMS by a weighted sum of Dirac measures:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mu approx sum_k omega_k  delta_xi_k","category":"page"},{"location":"","page":"Home","title":"Home","text":"where omega_kin mathbbR (resp. mathbbC), xi_k in mathbbR^n (resp. mathbbC^n) and delta_xi is the Dirac measure at the point xi. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the previous example, we use the command get_measure:","category":"page"},{"location":"","page":"Home","title":"Home","text":"w, Xi = get_measure(M)","category":"page"},{"location":"","page":"Home","title":"Home","text":"to obtain the weights w and the points Xi (the columns of the matrix):","category":"page"},{"location":"","page":"Home","title":"Home","text":"\nbeginarraycc\n04999999998860686  0499999999867594\nendarray\n\n\n\nbeginpmatrix\n07548776660872802  07548776660872801 \n06558656173161549  -06558656173161549 \nendpmatrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"so that the optimal moment sequence is approximately represented by the weighted sum of Dirac measures:","category":"page"},{"location":"","page":"Home","title":"Home","text":"w1 delta_Xi1 + w2 delta_Xi2","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed from Julia as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add https://github.com/AlgebraicGeometricModeling/MomentTools.jl\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sources: https://github.com/AlgebraicGeometricModeling/MomentTools.jl.","category":"page"},{"location":"code/2.optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"Pages = [\"2.optimization.md\"]","category":"page"},{"location":"code/2.optimization/#Solving-moment-programs","page":"Optimization","title":"Solving moment programs","text":"","category":"section"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"mmt_optimizer","category":"page"},{"location":"code/2.optimization/#MomentTools.mmt_optimizer","page":"Optimization","title":"MomentTools.mmt_optimizer","text":"mmt_optimizer(opt)\n\nDefine the default optimizer opt for the optimization problems created by MomentTools\n\n\n\n\n\nmmt_optimizer(opt, args...)\n\nDefine the default optimizer opt with its attribute args... for the optimization problems created by MomentTools\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"minimize","category":"page"},{"location":"code/2.optimization/#MomentTools.minimize","page":"Optimization","title":"MomentTools.minimize","text":"v, M = minimize(f, [e1, e2, ...], [p1, p2, ...], X, d, optimizer)\n\nCompute the infimum of f under the constraints e_i=0 and p_i geq 0 using a relaxation of order d on the moments in the variable X and the optimizer optimizer.\n\nSee optimize.\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"maximize","category":"page"},{"location":"code/2.optimization/#MomentTools.maximize","page":"Optimization","title":"MomentTools.maximize","text":"v, M = maximize(f, [e1, e2, ...], [p1, p2, ...], X, d, optimizer)\n\nSimilar to the function minimize but compute the supremun of f.\n\nSee optimize.\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"optimize","category":"page"},{"location":"code/2.optimization/#MomentTools.optimize","page":"Optimization","title":"MomentTools.optimize","text":"v, M = optimize(M)\n\nRun the optimizer on the moment program M and output the objective_value v and the moment program M. If the optimization program has no solution, it returns nothing and M.\n\n\n\n\n\nv, M = optimize(M, optimizer)\n\nRun the optimizer on the moment program M using the optimizer optimizer and output the objective_value v and the moment program M. If the optimization program has no solution, it returns nothing and M. \n\n\n\n\n\nv, M = optimize(sense, f, [e1, e2, ...], [p1, p2, ...], X, d)\n\nCompute the optimum of f under the constraints e_i =0 and p_i geq 0 using a relaxation of order d on the moments in the variable X. \n\nf e_i p_i should be polynomials in the variables X.\n'sense` is a Symbol in [:Inf,:inf,:Min,:min]  or :Sup, :sup, :Max, :max\nX is a tuple of variables\nd is the order of the relaxation\noptimizeris the optimizer used to solve the moment relaxation. By default it is MMT[:optimizer].\n\nIf the problem is feasible and has minimizers, it outputs\n\nv: the optimum value\nM: the moment model of type JuMP.Model\n\nExample\n\nusing MomentTools\n\nX  = @polyvar x1 x2\ne1 = x1^2-2\ne2 = (x2^2-3)*(x1*x2-2)\np1 = x1\np2 = 2-x2\nv, M = optimize(:inf, -x1, [e1, e2], [p1, p2], X, 3)\n\nTo recover the optimizers, see get_minimizers, get_measure, get_series.\n\n\n\n\n\nv, M = optimize([(f, set) ...], X, d)\n\nSolve the moment program of relaxation of order d in the variables X, defined by the constraint or objective paires (f, set) where f is a polynomial and set is a string\n\n\"inf\", \"sup\" to define the objective.\n\"=0\" to define zero constraints:\n\">=0\", \"<=0\" to define sign constraints\n\nIt outputs\n\nv: the optimal value\nM: the optimized moment program of type MOM.Model\n\nExample\n\nusing MomentTools\n\nX  = @polyvar x1 x2\ne1 = x1^2-2\ne2 = (x2^2-3)*(x1*x2-2)\np1 = x1\np2 = 2-x2\nv, M = optimize([(-x1, \"inf\"), (e1, \"=0\"), (e2, \"=0\"), (p1, \">=0\"), (p2>=0)], X, 3)\n\nTo recover the optimal values, see get_minimizers, get_measure, get_series.\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"polar_minimize","category":"page"},{"location":"code/2.optimization/#MomentTools.polar_minimize","page":"Optimization","title":"MomentTools.polar_minimize","text":"v, M = polar_minimize(f, [h1, h2, ...], [g1, g2, ...], X, degree_approx, optimizer)\n\nCompute the infimum of the f (equality constraints hi == 0 and the sign constraints gi >= 0) on the moment side. It does that calling minimize(...), replacing the equality constraints  [h1, h2, ...] with generators of the polar ideal.\n\nf, hi, gi should be polynomials in the variables X.\n\nIf the problem is feasible and has minimizers, it outputs\n\nv: the minimum value\nM: the moment model of type MOM.Model\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#Solving-Sum-Of-Squares-programs","page":"Optimization","title":"Solving Sum-Of-Squares programs","text":"","category":"section"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"min_ellipsoid ","category":"page"},{"location":"code/2.optimization/#MomentTools.min_ellipsoid","page":"Optimization","title":"MomentTools.min_ellipsoid","text":"Compute the minimal ellipsoid enclosing the point P of the semi-algebraic set defined by H[j]=0, G[k]>=0\n\nIt outputs the center c and the matrix U which columns are the principal axes of the ellipsoid.\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#Optimal-solutions","page":"Optimization","title":"Optimal solutions","text":"","category":"section"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"get_minimizers","category":"page"},{"location":"code/2.optimization/#MomentTools.get_minimizers","page":"Optimization","title":"MomentTools.get_minimizers","text":"get_minimizers(M, , t::Int64 = 2*M[:degree]-1)\n\nReturn the minimizer points  of the optimized moment program M, using moments of degree <=t (default: twice the order of the relaxation minus 2)\n\nget_minimizer(M)\n\n[1.41421 1.73205; 1.41421 1.41421; 1.41421 -1.73205]\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"get_measure","category":"page"},{"location":"code/2.optimization/#MomentTools.get_measure","page":"Optimization","title":"MomentTools.get_measure","text":"w, Xi = get_measure(M, t::Int64 = 2*M[:degree]-1 ,lambda = [(-1)^(k-1) for k in 1:M[:nu]])\n\nReturn the approximation of the moment sequence sum_i=1^nu lambda_i mu_i truncated to moments of degree <= t (default: twice the order of the relaxation minus 2), as weighted sum of Dirac measures: sum_k=1^r omega_k delta_xi_k where\n\nw is the vector of weights of the Dirac measures.\nXi is matrix of ntimes r support points of the corresponding Dirac measures. The column Xi[:,i] is the support point xi_i of the ith Dirac measure and its weights is w[i].\n\nw, Xi = get_measure(M)\n\n([0.1541368146508854, 0.5889741915171074, 0.256888993597116], [1.4142135624216647 1.414213562080608 1.4142135620270329; -1.732052464639053 1.4141771454788292 1.7319839273833693])\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"get_series","category":"page"},{"location":"code/2.optimization/#MomentTools.get_series","page":"Optimization","title":"MomentTools.get_series","text":"get_series(M)\n\nReturn the vector of nu=M[:nu] series of optimal moments of the optimized moment program M.\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"annihilator","category":"page"},{"location":"code/2.optimization/#MomentTools.annihilator","page":"Optimization","title":"MomentTools.annihilator","text":"K,I,P,B = annihilator(sigma::Series{R}, L, eqzero = is_zero)\n\nCompute a graded basis of the annihilator of the positive series σ in the space spanned by the list of monomials L.\n\nIt outputs:\n\nK the graded basis\nI the initial monomials of K\nP the orthogonal basis\nB the monomial basis\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#Decompositions","page":"Optimization","title":"Decompositions","text":"","category":"section"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"sos_decompose","category":"page"},{"location":"code/2.optimization/#MomentTools.sos_decompose","page":"Optimization","title":"MomentTools.sos_decompose","text":"Decompose f in the truncated quadratic module associated to the constraints H=0, G>=0:\n\ns, P, Q, v, M = sos_decompose(f,H,G,X,d, optimizer)\n\nsuch that \n\nf = s + sum_i pi*Hi+ sum_j qj*Gj      (*)\n\nwhere \n\nP[i] is a polynomial of degree le 2d -deg(Hi)\nQ[i] is a Sum of Squares of degree le 2d -deg(Gi)\ns is a Sum of Squares if v >= 0.\nv is the maximal smallest eigenvalue of Q0 such that s = (X^d)^t Q0 (X^d) in (*)\noptimizer (optional) is the optimizer used to solve the SDP program. The default value is MMT[:optimizer].\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"esos_decompose","category":"page"},{"location":"code/2.optimization/#MomentTools.esos_decompose","page":"Optimization","title":"MomentTools.esos_decompose","text":"Decompose g>0 at the real roots of f as a rational Sum of Squares and a multiple of f with rational coefficients.\n\nQ rational matrix which is positive definite if g>0 at the real roots of f\nq rational factor \n\nsuch that g = x^t Q x + q*f.\n\nThe options are:\n\nrounding = (Int64)k upper bound on the precision used in the rounding step\noptimizer = optimizer tool used for solving the SDP problem\nverbose = true or false to specify if information during the computation is printed or not\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/","page":"Optimization","title":"Optimization","text":"wsos_decompose","category":"page"},{"location":"code/2.optimization/#MomentTools.wsos_decompose","page":"Optimization","title":"MomentTools.wsos_decompose","text":"Decompose a polynomial as a weighted some of squares.\n\nW, P = wsos_decompose(f)\n\nsuch that \n\nf =  sum_i Wi*Pi^2\n\nwhere \n\nW[i] is a scalar\nP[i] is a polynomial\n\n\n\n\n\n","category":"function"},{"location":"expl/0.real_roots/#A-simple-univariate-example","page":"A simple univariate example","title":"A simple univariate example","text":"","category":"section"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"using DynamicPolynomials, MomentTools","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"X = @polyvar x\np = x^4+x^3-x-1","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"$ x^{4} + x^{3} - x - 1 $","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"We minimize x^2 under the constraint p=0. ","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"using JuMP, MosekTools; mmt_optimizer(JuMP.optimizer_with_attributes(Mosek.Optimizer, \"QUIET\" => true))\nv, M = minimize(x^2, [p], [], X, 4)","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"(0.9999999944816723, A JuMP Model\nMinimization problem with:\nVariables: 9\nObjective function type: AffExpr\n`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 6 constraints\n`Vector{AffExpr}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: NO_OPTIMIZER\nSolver name: No optimizer attached.\nNames registered in the model: basis, degree, dual, index, moments, monomials, nu, type, variables, y)","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"We use Mosek optimizer to solve the underlying SDP optimization problem. The first argument x^2 of the function minimize is the objective function. The second argument is the array of equality constraints, the third is the array of non-negativity constraints (here empty).","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"The function minimize returns v the optimal value found (here it is approx 1) and M the Moment Model built for the optimization (which type is MomentTools.MOM.Model). ","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"The minimizers can be obtained from M as follows:","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"get_minimizers(M)","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"1×2 Matrix{Float64}:\n 1.0  -1.0","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"The minimizers are presented as a ntimes r matrix, where n is the number of variables (here n=1) and r is the number of points (here r=2). ","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"An approximation  of the associate measure can be obtained as follows:","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"get_measure(M)","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"([0.4849875221398623, 0.5150124733228074], [0.9999999995824745 -1.000000001094948])","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"It corresponds approximately to the measure 05 delta_-1 + 05 delta_1 where delta_x is the Dirac measure supported on x.","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"Next, we search the root(s) with x geq 0. For that purpose, we minimize nothing (i.e. 1) and add the non-negativity constraint xgeq 0:","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"v, M = minimize(nothing, [p], [x], X, 4)\nget_minimizers(M)","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"1×1 Matrix{Float64}:\n 1.0000000000818177","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"Now we search the negative root with maximal value of x.","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"v, M = maximize(x, [p], [-x], X, 4)\nget_minimizers(M)","category":"page"},{"location":"expl/0.real_roots/","page":"A simple univariate example","title":"A simple univariate example","text":"1×1 Matrix{Float64}:\n -0.9999999994227468","category":"page"}]
}
