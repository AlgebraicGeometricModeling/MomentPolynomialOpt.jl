var documenterSearchIndex = {"docs":
[{"location":"expl/2.positive_polynomial/#The-minimizers-of-Motzkin-polynomial","page":"The minimizers of Motzkin polynomial","title":"The minimizers of Motzkin polynomial","text":"using DynamicPolynomials, MomentPolynomialOpt\nusing JuMP, MosekTools; mpo_optimizer(JuMP.optimizer_with_attributes(Mosek.Optimizer, \"QUIET\" => true));\n\nWe use Mosek solver for the convex optimization on SDP matrices.\n\nX  = @polyvar x y\nmotz = x^4*y^2 + x^2*y^4 - 3x^2*y^2  + 1 \n\n$ 1 - 3x^{2}y^{2} + x^{2}y^{4} + x^{4}y^{2} $\n\nThis is Motzkin polynomial, which is non-negative but not a sum of squares.\n\n(Image: Motzkin)\n\nWe construct a moment relaxation of order 6 to minimize the polynomial:\n\nv, M = minimize(motz,[],[],X,6)\n\n(-1.1921921828168573, A JuMP Model\nMinimization problem with:\nVariables: 91\nObjective function type: AffExpr\n`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 1 constraint\n`Vector{AffExpr}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: ATTACHED_OPTIMIZER\nSolver name: Dual model with Mosek attached\nNames registered in the model: mu, type)\n\nv\n\n-1.1921921828168573\n\nThe objective value is a lower bound of the actual mimimal value 0 of Motzkin polynomial.\n\nWe extract a measure from the sequence of moments:\n\nw, Xi = get_measure(M)\n\n([0.0026883163983826715, 0.01047896196826447, 0.0027735765469068907, 0.012843909288925688, 0.19616936321231251, 0.03434046740021252, 0.21509640717639428, 0.21509640717622966, 0.03434046739971617, 0.19616936321243933, 0.012843909288991885, 0.0027735765469080512, 0.01047896196826921, 0.0026883163983818232], [-32.48832713409418 -26.784975212459656 … 26.78497521246037 32.48832713409392; -13.350812204541068 -6.394449983606535 … 6.394449983604005 13.350812204542907])\n\nw is the vector of weights and Xi is the matrix of points, that is support of the measure mu=sum_i omega_i delta_Xi_i. w[i] is the weight of the Dirac measure corresponding to the point Xi[:,i] in this decomposition.\n\nHere no point is found to approximate the optimal moment sequence.\n\nNow, to find the minimizers, we add as constraints, that the gradient of the polynomial should vanish:\n\nJ = differentiate(motz,X)\nv, M = minimize(motz, J,[], X, 6)\n\n(3.425090500108752e-8, A JuMP Model\nMinimization problem with:\nVariables: 91\nObjective function type: AffExpr\n`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 73 constraints\n`Vector{AffExpr}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: ATTACHED_OPTIMIZER\nSolver name: Dual model with Mosek attached\nNames registered in the model: mu, type)\n\nw, Xi = get_measure(M)\n\n(ComplexF64[0.250000291733613 + 1.3997848659793657e-23im, 0.24999968122266356 - 2.992791069588476e-23im, 0.24999968122266475 + 9.916715552616423e-23im, 0.25000029173361216 - 1.0263318372273331e-23im], ComplexF64[1.000000372268364 - 2.4736625661361147e-23im 0.9999968219304204 - 1.0869941598112134e-21im -0.9999968219304202 + 1.0028089321701322e-21im -1.0000003722683641 + 1.7436285550353185e-23im; -1.000000120346944 - 3.861016728617506e-23im 0.999991461488931 - 1.6966350594808994e-21im -0.9999914614889309 + 1.5652345294854395e-21im 1.000000120346944 + 2.7215429914249185e-23im])\n\nThe decomposition gives almost real points Xi for the support:\n\nreal.(Xi)\n\n2×4 Matrix{Float64}:\n  1.0  0.999997  -0.999997  -1.0\n -1.0  0.999991  -0.999991   1.0\n\nWe find approximately the 4 minimizers (pm 1 pm 1).\n\nFinally, to find the minimizers, we try another strategy and add the constraint that the polynomial should vanish, since we know that its minimal value (at the minimizers) is 0:\n\nv, M = minimize(motz, [motz], [], X, 6)\n\n(1.028768181754458e-10, A JuMP Model\nMinimization problem with:\nVariables: 91\nObjective function type: AffExpr\n`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 29 constraints\n`Vector{AffExpr}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: ATTACHED_OPTIMIZER\nSolver name: Dual model with Mosek attached\nNames registered in the model: mu, type)\n\nw, Xi = get_measure(M)\n\n([0.25001256622985196, 0.24998736643296088, 0.24998736643296096, 0.25001256622985185], [1.0000146220665007 0.9989130108854624 -0.9989130108854603 -1.0000146220665007; 1.0000098944687037 -0.9983942096911503 0.9983942096911474 -1.0000098944687041])\n\nreal.(Xi)\n\n2×4 Matrix{Float64}:\n 1.00001   0.998913  -0.998913  -1.00001\n 1.00001  -0.998394   0.998394  -1.00001\n\nThe minimizers are also close to that actual minimizers (pm 1 pm 1).","category":"section"},{"location":"expl/1.maximizers/#Solving-a-polynomial-optimization-problem","page":"Solving a polynomial optimization problem","title":"Solving a polynomial optimization problem","text":"using DynamicPolynomials, MomentPolynomialOpt\n\nX  = @polyvar x1 x2\n\ne1 = x1^2-2\ne2 = (x2^2-3)*(x1*x2-2)\n\np1 = x1\np2 = 2-x2;\n\nWe are looking for the points with maximal x_1 in the set e_1=e_2=0 such that p_1geq 0, p_2geq 0. \n\nWe solve a SDP relaxation of order d=4, where the variables of the underlying convex optimization problem are the moments of order le 2d in the variables x_1 x_2.\n\nusing CSDP;\nv, M = maximize(x1, [e1, e2], [p1,p2], X, 4, CSDP.Optimizer)\nv\n\nCSDP 6.2.0\nIter:  0 Ap: 0.00e+00 Pobj:  0.0000000e+00 Ad: 0.00e+00 Dobj:  0.0000000e+00 \nIter:  1 Ap: 7.96e-01 Pobj:  1.3512389e+00 Ad: 7.77e-01 Dobj: -1.6779112e-01 \nIter:  2 Ap: 5.89e-01 Pobj:  1.3774675e+01 Ad: 6.75e-01 Dobj: -3.1220844e-01 \nIter:  3 Ap: 1.45e-01 Pobj:  1.6171643e+02 Ad: 1.90e-01 Dobj: -7.3834519e-01 \nIter:  4 Ap: 7.11e-01 Pobj: -7.5743600e+00 Ad: 6.50e-01 Dobj: -1.5160115e+00 \nIter:  5 Ap: 8.65e-01 Pobj: -7.6704896e+00 Ad: 8.84e-01 Dobj: -1.3959650e+00 \nIter:  6 Ap: 7.98e-01 Pobj: -3.7100039e+00 Ad: 7.34e-01 Dobj: -1.4143632e+00 \nIter:  7 Ap: 7.35e-01 Pobj: -2.6064472e+00 Ad: 7.48e-01 Dobj: -1.4135877e+00 \nIter:  8 Ap: 5.35e-01 Pobj: -2.1446579e+00 Ad: 8.01e-01 Dobj: -1.4142031e+00 \nIter:  9 Ap: 6.65e-01 Pobj: -1.7242201e+00 Ad: 7.02e-01 Dobj: -1.4141766e+00 \nIter: 10 Ap: 6.91e-01 Pobj: -1.5362595e+00 Ad: 8.31e-01 Dobj: -1.4142130e+00 \nIter: 11 Ap: 7.66e-01 Pobj: -1.4508474e+00 Ad: 6.82e-01 Dobj: -1.4142118e+00 \nIter: 12 Ap: 6.46e-01 Pobj: -1.4304738e+00 Ad: 7.98e-01 Dobj: -1.4142134e+00 \nIter: 13 Ap: 6.36e-01 Pobj: -1.4212252e+00 Ad: 7.70e-01 Dobj: -1.4142135e+00 \nIter: 14 Ap: 7.07e-01 Pobj: -1.4166180e+00 Ad: 1.00e+00 Dobj: -1.4142136e+00 \nIter: 15 Ap: 9.27e-01 Pobj: -1.4144197e+00 Ad: 1.00e+00 Dobj: -1.4142136e+00 \nIter: 16 Ap: 9.49e-01 Pobj: -1.4142278e+00 Ad: 1.00e+00 Dobj: -1.4142136e+00 \nIter: 17 Ap: 9.44e-01 Pobj: -1.4142151e+00 Ad: 1.00e+00 Dobj: -1.4142136e+00 \nIter: 18 Ap: 1.00e+00 Pobj: -1.4142137e+00 Ad: 1.00e+00 Dobj: -1.4142136e+00 \nIter: 19 Ap: 9.95e-01 Pobj: -1.4142136e+00 Ad: 1.00e+00 Dobj: -1.4142136e+00 \nIter: 20 Ap: 1.00e+00 Pobj: -1.4142136e+00 Ad: 9.25e-01 Dobj: -1.4142136e+00 \nIter: 21 Ap: 6.57e-01 Pobj: -1.4142136e+00 Ad: 6.03e-01 Dobj: -1.4142136e+00 \nSuccess: SDP solved\nPrimal objective value: -1.4142136e+00 \nDual objective value: -1.4142136e+00 \nRelative primal infeasibility: 1.17e-09 \nRelative dual infeasibility: 6.11e-10 \nReal Relative Gap: 4.77e-09 \nXZ Relative Gap: 4.20e-09 \nDIMACS error measures: 1.17e-09 0.00e+00 4.81e-09 0.00e+00 4.77e-09 4.20e-09\n\n\n\n\n\n1.4142135623764274\n\nThe output of the function maximize is the optimal value v and the optimization model M. \n\nThe points which reach the optimal value, can be obtained as follows: \n\nXi = get_minimizers(M)\n\n2×3 Matrix{Float64}:\n 1.41421  1.41421   1.41421\n 1.73196  1.41415  -1.73205\n\nEach column of this matrix represents a point. It is an ntimes r  matrix, where n is the number of coordinates in X and r is the number of points.\n\nThe weighted sum of Dirac measures associated to the optimal moment sequence can be obtained as follows:\n\nw, Xi = get_measure(M)\n\n([0.2846422969212594, 0.48611125587805604, 0.22924644720334292], [1.4142135622523302 1.4142135622777432 1.414213562369705; 1.7319614907125995 1.414148281759339 -1.7320524561055801])\n\nw is the vector of weights and Xi is the matrix of points, that is support of the measure mu=sum_i omega_i delta_Xi_i.\n\nHere is another way to solve it. We describe it as a Polynomial Optimization Problem and use the function optimize:\n\npop = [(x1, \"sup\"), (e1,\"=0\"),(e2 ,\"=0\"),(p1,\">=0\"),(p2,\">=0\")]\n\n5-element Vector{Tuple{AbstractPolynomialLike{Int64}, String}}:\n (x1, \"sup\")\n (-2 + x1², \"=0\")\n (6 - 2x2² - 3x1x2 + x1x2³, \"=0\")\n (x1, \">=0\")\n (2 - x2, \">=0\")\n\nv, M = optimize(pop, X, 4, CSDP.Optimizer)\n\nCSDP 6.2.0\nIter:  0 Ap: 0.00e+00 Pobj:  0.0000000e+00 Ad: 0.00e+00 Dobj:  0.0000000e+00 \nIter:  1 Ap: 7.96e-01 Pobj:  1.3512389e+00 Ad: 7.77e-01 Dobj: -1.6779112e-01 \nIter:  2 Ap: 5.89e-01 Pobj:  1.3774675e+01 Ad: 6.75e-01 Dobj: -3.1220844e-01 \nIter:  3 Ap: 1.45e-01 Pobj:  1.6171643e+02 Ad: 1.90e-01 Dobj: -7.3834519e-01 \nIter:  4 Ap: 7.11e-01 Pobj: -7.5743600e+00 Ad: 6.50e-01 Dobj: -1.5160115e+00 \nIter:  5 Ap: 8.65e-01 Pobj: -7.6704896e+00 Ad: 8.84e-01 Dobj: -1.3959650e+00 \nIter:  6 Ap: 7.98e-01 Pobj: -3.7100039e+00 Ad: 7.34e-01 Dobj: -1.4143632e+00 \nIter:  7 Ap: 7.35e-01 Pobj: -2.6064472e+00 Ad: 7.48e-01 Dobj: -1.4135877e+00 \nIter:  8 Ap: 5.35e-01 Pobj: -2.1446579e+00 Ad: 8.01e-01 Dobj: -1.4142031e+00 \nIter:  9 Ap: 6.65e-01 Pobj: -1.7242201e+00 Ad: 7.02e-01 Dobj: -1.4141766e+00 \nIter: 10 Ap: 6.91e-01 Pobj: -1.5362595e+00 Ad: 8.31e-01 Dobj: -1.4142130e+00 \nIter: 11 Ap: 7.66e-01 Pobj: -1.4508474e+00 Ad: 6.82e-01 Dobj: -1.4142118e+00 \nIter: 12 Ap: 6.46e-01 Pobj: -1.4304738e+00 Ad: 7.98e-01 Dobj: -1.4142134e+00 \nIter: 13 Ap: 6.36e-01 Pobj: -1.4212252e+00 Ad: 7.70e-01 Dobj: -1.4142135e+00 \nIter: 14 Ap: 7.07e-01 Pobj: -1.4166180e+00 Ad: 1.00e+00 Dobj: -1.4142136e+00 \nIter: 15 Ap: 9.27e-01 Pobj: -1.4144197e+00 Ad: 1.00e+00 Dobj: -1.4142136e+00 \nIter: 16 Ap: 9.49e-01 Pobj: -1.4142278e+00 Ad: 1.00e+00 Dobj: -1.4142136e+00 \nIter: 17 Ap: 9.44e-01 Pobj: -1.4142151e+00 Ad: 1.00e+00 Dobj: -1.4142136e+00 \nIter: 18 Ap: 1.00e+00 Pobj: -1.4142137e+00 Ad: 1.00e+00 Dobj: -1.4142136e+00 \nIter: 19 Ap: 9.95e-01 Pobj: -1.4142136e+00 Ad: 1.00e+00 Dobj: -1.4142136e+00 \nIter: 20 Ap: 1.00e+00 Pobj: -1.4142136e+00 Ad: 9.25e-01 Dobj: -1.4142136e+00 \nIter: 21 Ap: 6.57e-01 Pobj: -1.4142136e+00 Ad: 6.03e-01 Dobj: -1.4142136e+00 \nSuccess: SDP solved\nPrimal objective value: -1.4142136e+00 \nDual objective value: -1.4142136e+00 \nRelative primal infeasibility: 1.17e-09 \nRelative dual infeasibility: 6.11e-10 \nReal Relative Gap: 4.77e-09 \nXZ Relative Gap: 4.20e-09 \nDIMACS error measures: 1.17e-09 0.00e+00 4.81e-09 0.00e+00 4.77e-09 4.20e-09\n\n\n\n\n\n(1.4142135623764274, A JuMP Model\nMaximization problem with:\nVariables: 45\nObjective function type: JuMP.VariableRef\n`JuMP.AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 44 constraints\n`Vector{JuMP.AffExpr}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 3 constraints\nModel mode: AUTOMATIC\nCachingOptimizer state: ATTACHED_OPTIMIZER\nSolver name: Dual model with CSDP attached\nNames registered in the model: mu, type)\n\nget_minimizers(M)\n\n2×3 Matrix{Float64}:\n  1.41421  1.41421  1.41421\n -1.73205  1.41415  1.73196","category":"section"},{"location":"code/1.moment_model/#Moment-Program","page":"Moment Program","title":"Moment Program","text":"Pages = [\"1.moment_model.md\"]","category":"section"},{"location":"code/1.moment_model/#Constraints","page":"Moment Program","title":"Constraints","text":"","category":"section"},{"location":"code/1.moment_model/#Objective-function","page":"Moment Program","title":"Objective function","text":"","category":"section"},{"location":"code/1.moment_model/#MomentPolynomialOpt.moments","page":"Moment Program","title":"MomentPolynomialOpt.moments","text":"moments(M, X, d::Int, symb::Symbol...)\n\nDefine variables for the moments of the monomials of degree less than d in the variables  X. If\n\nsymb == :PSD, non-negativity constraints are added;\nsymb == :PRB, unit mass and non-negativity constraints are added.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/#MomentPolynomialOpt.MOM.Model","page":"Moment Program","title":"MomentPolynomialOpt.MOM.Model","text":"M = MOM.Model( `sense`, f, H, G, X, d)\n\nConstruct the Moment Program in the variables X of order d.\n\nsense == :inf or :sup\nf polynomial objective function\nH =[h1, h2, ...] array of polynomial equality constraints (can be empty)\nG =[g1, g2, ...] array of non-negativity constraints (can be empty)\nX is the vector of variables\nd is the order of the moment relaxation.\n\n\n\n\n\nM = MOM.Model(C, X, d)\n\nConstruct the Moment Program where\n\nC is a vector of pairs (f, sense ) of objective or constraints where f is a polynomial and sense is \"inf\", \"min\", \"sup\", \"max\", \">=0\", \"<=0\", \"=0\", or an interval \nX is the vector of variables\nd is the order of the moment relaxation.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/#MomentPolynomialOpt.MOM.add_constraint_zero","page":"Moment Program","title":"MomentPolynomialOpt.MOM.add_constraint_zero","text":"add_constraint_zero(M, eq, mu::Moments)\n\nAdd to the moment program M, the constraints eqstar mu = 0, that is all the constraints mu(p*m)==0 for degree(m) le 2*degree(M)-degree(p).\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/#MomentPolynomialOpt.MOM.add_constraint_nneg","page":"Moment Program","title":"MomentPolynomialOpt.MOM.add_constraint_nneg","text":"add_constraint_nneg(M, mu::Moments, g)\n\nAdd to the moment program M, the constraints g star mu succeq 0, that is the moment matrix of gstar mu is PSD.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/#MomentPolynomialOpt.MOM.add_constraint_moment","page":"Moment Program","title":"MomentPolynomialOpt.MOM.add_constraint_moment","text":"add_constraint_moment(M, mu::Moments,  p => v)\n\nAdd to the moment program M, the constraint mu(p) - v == 0.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/#MomentPolynomialOpt.MOM.add_constraint_unitmass","page":"Moment Program","title":"MomentPolynomialOpt.MOM.add_constraint_unitmass","text":"add_constraint_unitmass(M, mu)\n\nAdd to the moment program M, the constraint langle mu 1 rangle - 1 = 0.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/#MomentPolynomialOpt.MOM.set_objective","page":"Moment Program","title":"MomentPolynomialOpt.MOM.set_objective","text":"set_objective(M, sense, p, mu)\n\nSet the \"inf\" or \"sup\" objective function to  sum_i=1^nu langle pstar mu_i 1 rangle where p is a polynomial.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/#MomentPolynomialOpt.MOM.set_objective_tv","page":"Moment Program","title":"MomentPolynomialOpt.MOM.set_objective_tv","text":"set_objective_tv(M)\n\nSet the objective function of the moment program to the total variation of the moment sequence mu, that is  the sum  of the unit mass of the positive moment sequences sum_i=1^nu langle mu_i 1rangle.\n\n\n\n\n\n","category":"function"},{"location":"code/1.moment_model/#MomentPolynomialOpt.MOM.set_objective_ncl","page":"Moment Program","title":"MomentPolynomialOpt.MOM.set_objective_ncl","text":"set_objective_ncl(M)\n\nSet the objective function of moment program to the nuclear norm or equivalently the trace of the moment matrices.\n\n\n\n\n\n","category":"function"},{"location":"package/#About-MomentPolynomialOpt.jl","page":"About the package","title":"About MomentPolynomialOpt.jl","text":"","category":"section"},{"location":"package/#Dependencies","page":"About the package","title":"Dependencies","text":"A version of Julia >= 1.3 should be used.\n\nIt depends on the following packages, which are installed automatically:\n\nCombinatorics for the computation of polar ideals.\nDualization for the use of dual optimization solvers on the moment optimization problems.\nDynamicPolynomials \nJuMP\nLinearAlgebra\nMultivariateSeries (v>=1.1.2) for the representation of moment sequences and the decomposition of series.\n\nTo solve the moment optimization problems, an external SDP optimizers has  to be installed, such as MosekTools, CSDP, ...","category":"section"},{"location":"package/#Development","page":"About the package","title":"Development","text":"The git project of the package is     https://github.com/AlgebraicGeometricModeling/MomentPolynomialOpt.jl.\n\nThe main developpers are (so far)\n\nLorenzo Baldi\nBernard Mourrain\n\nThe development is done in relation with the activity of the network POEMA.","category":"section"},{"location":"package/#See-also","page":"About the package","title":"See also","text":"Other Julia packages are currently developed for polynomial and moment optimization:\n\nMomentOpt\nSumOfSquares\nPolyJuMP","category":"section"},{"location":"expl/3.positive_moment_sequences/#Constraints-on-Positive-Moment-Sequences","page":"Constraints on Positive Moment Sequences","title":"Constraints on Positive Moment Sequences","text":"using DynamicPolynomials, MultivariateSeries, MomentPolynomialOpt\nusing JuMP, MosekTools; mpo_optimizer(Mosek.Optimizer, \"QUIET\" => true);\n\nWe define a moment model  in variables xy:\n\nX = @polyvar x y\n\nM = MOM.Model()\nd = 10\n\n10\n\nWe define now a moment sequence mu_1 with is Positive Semi-Definite (.i.e non-negative on squares) and non-negative on the unit ball, truncated in degree 2d:\n\nmu1 = moments(M,X,2*d,:PSD)\n\ng1 = 1-x^2-y^2\n\n# p1 * mu >= 0\nMOM.add_constraint_nneg(M, mu1, g1);\n\nWe consider a second moment sequence mu_2 which is PSD and non-negative on the bux mathbbB=-11^2: \n\nmu2 = moments(M, X, 2*d, :PSD)\n\nq1 = 1-x^2\nq2 = 1-y^2\n\n# q1 * mu_2 >= 0, q2 * mu_2 >=0\nMOM.add_constraint_nneg(M, mu2, q1)\nMOM.add_constraint_nneg(M, mu2, q2);\n\nNow, we impose that mu_1+mu_2= lambda where lambda is the Lebesgue measure on the box mathbbB. It translates into moment constraintes:\n\nfunction lebesgue(m)\n    e = exponents(m); \n    return ((1-(-1)^(e[1]+1))/(e[1]+1))*((1-(-1)^(e[2]+1))/(e[2]+1))\nend\n\nL = monomials(X, 0:2*d) \nfor m in L\n    @constraint(M, mmt(mu1, m) + mmt(mu2,m) - lebesgue(m) == 0)\nend\n\nFinally, we optimize the total mass of mu_1 to get the volume of S.\n\n# sup  <mu_1,1>  \n@objective(M, Max, mmt(mu1,1) )\n\nv, M = optimize(M)\n\n(3.5833175500047845, A JuMP Model\nMaximization problem with:\nVariables: 462\nObjective function type: AffExpr\n`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 231 constraints\n`Vector{AffExpr}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 5 constraints\nModel mode: AUTOMATIC\nCachingOptimizer state: ATTACHED_OPTIMIZER\nSolver name: Dual model with Mosek attached\nNames registered in the model: mu, type)\n\n","category":"section"},{"location":"code/3.decomposition/#Decompositions","page":"Decompositions","title":"Decompositions","text":"Pages = [\"2.optimization.md\"]\n\nMoment optimisation programs can be use to compute decomposition of different forms.","category":"section"},{"location":"code/3.decomposition/#Sum-of-Square-Decompositions","page":"Decompositions","title":"Sum of Square Decompositions","text":"","category":"section"},{"location":"code/3.decomposition/#Tensor-Decompositions","page":"Decompositions","title":"Tensor Decompositions","text":"","category":"section"},{"location":"code/3.decomposition/#MomentPolynomialOpt.sos_decompose","page":"Decompositions","title":"MomentPolynomialOpt.sos_decompose","text":"Decompose f in the truncated quadratic module associated to the constraints H=0, G>=0:\n\n WS, P, v, M = sos_decompose(f, H, G, X, d, optimizer; exact = false, round = Inf64 )\n\nsuch that \n\nf = sum_k omega_0k q_0k^2 + sum_j (sum_k omega_jk q_jk^2)*Gj + sum_i Pi*Hi              (+)\n\nwhere\n\nf is the polynomial to decompose\nH = [...] are the equality constraints\nG = [...] are the non-negativity constraints\nX is the set of variables\nd is the order of the relaxation\noptimizer (optional) is the optimizer used to solve the SDP program. The default value is MPO[:optimizer]\nif exact = true then an exact decomposition with rational coefficients is computed.\nif the option round = p is provided, then a round of at most pdigits is used.\n\nIn the output decomposition, \n\nWS[1] = [w0, Q0] where w0 is an array of weights omega_0k in (+) and Q0 is an array of polynomials (q_{0,k} in (+)) of degree le 2d -deg(Gi)\nWS[j+1] as WS[1] for the weights omega_jk and polynomials q_jkin (+)\nP[i] is a polynomial of degree le 2d - deg(Hi)\nv is the maximal smallest eigenvalue of S0 such that (X^d)^t S0 (X^d) = sum_k omega_0k q_0k^2 in (*)\nMis the JuMP optimization model \n\n\n\n\n\n","category":"function"},{"location":"code/3.decomposition/#MomentPolynomialOpt.w_cholesky","page":"Decompositions","title":"MomentPolynomialOpt.w_cholesky","text":"   w, L = w_cholesky(A)\n\nCompute the weighted Cholesky factorisation so that 'L^tdiagm(w)L = A`\n\n\n\n\n\n","category":"function"},{"location":"code/3.decomposition/#MomentPolynomialOpt.MomentTensorDecomposition.symm_tens_decomp","page":"Decompositions","title":"MomentPolynomialOpt.MomentTensorDecomposition.symm_tens_decomp","text":"w, Xi = symm_tens_decomp(X, l, F; rescaling=1, use_kernel=true, weight_type=:real)\n\nDecompose a symmetric tensor represented as a homogeneous polynomial F into a weighted sum of rank-1 components. Given a homogeneous polynomial F0 of degree d, find weights w and points Xi such that F approx sum_i w_i langle X_i x rangle^d.\n\nArguments\n\nX: Vector of polynomial variables\nl: Relaxation order for the moment problem\nF: Homogeneous polynomial to decompose\nrescaling: Scaling factor to be set so decomposition points lie in radius 1 sphere (default: 1)\nuse_kernel: Include kernel constraints from Hankel nullspace (default: true)\nweight_type: :real for signed weights or :positive for positive-only weights (default: :real)\n\nReturns\n\nw: Vector of weights\nXi: Matrix of decomposition points (each column is a point)\n\n\n\n\n\n","category":"function"},{"location":"#Moment-Polynomial-Optimization","page":"Home","title":"Moment Polynomial Optimization","text":"This Julia package provides tools for solving polynomial and moment optimization problems on semi-algebraic sets defined by polynomial sign and equality constraints. In particular, it allows to optimize vectors of moments sequences that satisfy positivity constraints or mass constraints. It is based on MoMent (MoM) and Sum-of-Squares (SOS) convex relaxations, which are solved by  an external Semi-Definite Program (SDP) solvers such as CSDP, MosekTools, ...  Extraction tools allow to recover the global optimizers of the problem from optimal moment sequences, using flat truncation properties.\n\nAs an illustrative example, we consider the set S defined by the inequalities \n\nleftbeginarrayl\nx^3 - y^2 ge 0\n1 - x^2 -y^2 ge 0\nendarray\nright\n\nThis is the blue domain below:\n\n(Image: DomainCusp)\n\nWe want to maximize the objective function y^2 on this domain and to find the maximizer points. Here is how it can be done in MomentPolynomialOpt, with the SDP solver CSDP.\n\nusing MomentPolynomialOpt, DynamicPolynomials\nusing CSDP; mpo_optimizer(CSDP.Optimizer)\n\nX = @polyvar x y\n\nG = [1 - x^2 - y^2, x^3-y^2 ]  # Non-negativity constraints\n\nf = y^2  # objective function\n\nv, M = maximize(f, [], G, X, 3) # relaxation at order 3\n\nw, Xi = get_measure(M)  # recovers the weighted sum of Dirac measures from the moments\n\nThis gives the following weigts and points of the weight sum of Dirac measures  associated to the optimal moment sequence. \n\n\nbeginarraycc\n04999999998860686  0499999999867594\nendarray\n\n\n\nbeginpmatrix\n07548776660872802  07548776660872801 \n06558656173161549  -06558656173161549 \nendpmatrix\n\nThese points, which are the maximizers of the optimization problem are the top and bottom \"corner\" points of the domain.","category":"section"},{"location":"#Optimization","page":"Home","title":"Optimization","text":"The package allows to solve optimization problems on Pseudo Moment Sequences (PMS). A PMS is a sequence of values  mu=(mu_alpha) indexed by the monomial exponents alpha in mathbbN^n or equivalently a linear functional mu p in mathbbRmathbfx mapsto langle mu p rangle = sum_alpha p_alpha mu_alpha . It is positive if for all pin mathbbRmathbfx, we have   langle mu p^2 rangle geq 0 .\n\nOptimization problems of the following form are considered:\n\nbeginarrayrl\nmathrminf_mu_i in PMS  sum_i langle f_istar mu_i 1 rangle \nst   sum_i g_ijstar mu_i succeq 0 quad j=1ldots n_1  \n       sum_i h_ijstar mu_i = 0 quad j=1ldots n_2\n       sum_i langle p_ijstar mu_i 1 rangle ge 0  quad j=1ldots n_3\n       sum_i langle q_ijstar mu_i 1 rangle = 0 quad j=1ldots n_4 \nendarray\n\nwhere\n\nmu_i are positive PMS,\nf_i g_ij h_ij p_ij q_ij in mathbbRmathbfx are multivariate polynomials.\n\nThe solution of such optimization problem is approximated by the solution of a truncated relaxation of the problem, which is a convex optimization problem on Positive SemiDefinite matrices. Tools to construct such moment relaxation of a given order are available in the package.","category":"section"},{"location":"#Decomposition","page":"Home","title":"Decomposition","text":"Decomposition tools are available to decompose or approximate a PMS by a weighted sum of Dirac measures:\n\nmu approx sum_k omega_k  delta_xi_k\n\nwhere omega_kin mathbbR (resp. mathbbC), xi_k in mathbbR^n (resp. mathbbC^n) and delta_xi is the Dirac measure at the point xi. \n\nIn the previous example, we use the command get_measure:\n\nw, Xi = get_measure(M)\n\nto obtain the weights w and the points Xi (the columns of the matrix):\n\n\nbeginarraycc\n04999999998860686  0499999999867594\nendarray\n\n\n\nbeginpmatrix\n07548776660872802  07548776660872801 \n06558656173161549  -06558656173161549 \nendpmatrix\n\nso that the optimal moment sequence is approximately represented by the weighted sum of Dirac measures:\n\nw1 delta_Xi1 + w2 delta_Xi2","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package can be installed from Julia as follows:\n\n] add MomentPolynomialOpt\n\n\nSources: https://github.com/AlgebraicGeometricModeling/MomentPolynomialOpt.jl.","category":"section"},{"location":"code/2.optimization/#Moment-Optimization-Programs","page":"Moment Optimization Programs","title":"Moment Optimization Programs","text":"Pages = [\"2.optimization.md\"]\n\nAn SDP optimizer package should be installed to be able to run the moment optimization.","category":"section"},{"location":"code/2.optimization/#Solving-Moment-Optimization-Programs","page":"Moment Optimization Programs","title":"Solving Moment Optimization Programs","text":"","category":"section"},{"location":"code/2.optimization/#Optimal-solutions","page":"Moment Optimization Programs","title":"Optimal solutions","text":"","category":"section"},{"location":"code/2.optimization/#Extended-Moment-Optimization-Programs","page":"Moment Optimization Programs","title":"Extended Moment Optimization Programs","text":"","category":"section"},{"location":"code/2.optimization/#Combined-Moment-Optimization-Programs","page":"Moment Optimization Programs","title":"Combined Moment Optimization Programs","text":"","category":"section"},{"location":"code/2.optimization/#MomentPolynomialOpt.mpo_optimizer","page":"Moment Optimization Programs","title":"MomentPolynomialOpt.mpo_optimizer","text":"mpo_optimizer(opt)\n\nDefine the default optimizer opt for the optimization problems created by MomentPolynomialOpt\n\nExample\n\nusing CSDP\nmpo_optimizer(CSDP.Optimizer)\n\n\n\n\n\nmpo_optimizer(opt, args...)\n\nDefine the default optimizer opt with its attribute args... for the optimization problems created by MomentPolynomialOpt\n\nExample\n\nusing MosekTools\nmpo_optimizer(Mosek.Optimizer, \"QUIET\" =>true)\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#MomentPolynomialOpt.minimize","page":"Moment Optimization Programs","title":"MomentPolynomialOpt.minimize","text":"v, M = minimize(f, [e1, e2, ...], [p1, p2, ...], X, d, optimizer)\n\nCompute the infimum of f under the constraints e_i=0 and p_i geq 0 using a relaxation of order d on the moments in the variable X and the optimizer optimizer.\n\nSee optimize.\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#MomentPolynomialOpt.maximize","page":"Moment Optimization Programs","title":"MomentPolynomialOpt.maximize","text":"v, M = maximize(f, [e1, e2, ...], [p1, p2, ...], X, d, optimizer)\n\nSimilar to the function minimize but compute the supremun of f.\n\nSee optimize.\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#MomentPolynomialOpt.optimize","page":"Moment Optimization Programs","title":"MomentPolynomialOpt.optimize","text":"v, M = optimize(sense, f, [e1, e2, ...], [p1, p2, ...], X, d)\n\nCompute the optimum of f under the constraints e_i =0 and p_i geq 0 using a relaxation of order d on the moments in the variable X. \n\nf e_i p_i should be polynomials in the variables X.\n'sense` is a Symbol in [:Inf, :inf, :Min,:min]  or :Sup, :sup, :Max, :max\nX is a tuple of variables\nd is the order of the relaxation\noptimizeris the optimizer used to solve the moment relaxation. By default it is MPO[:optimizer].\n\nIf the problem is feasible and has minimizers, it outputs\n\nv: the optimum value\nM: the moment model of type JuMP.Model\n\nExample\n\nusing MomentPolynomialOpt\n\nX  = @polyvar x1 x2\ne1 = x1^2-2\ne2 = (x2^2-3)*(x1*x2-2)\np1 = x1\np2 = 2-x2\nv, M = optimize(:inf, -x1, [e1, e2], [p1, p2], X, 3)\n\nTo recover the optimizers, see get_minimizers, get_measure, get_series.\n\n\n\n\n\nv, M = optimize([(f, set) ...], X, d)\n\nSolve the moment program of relaxation of order d in the variables X, defined by the constraint or objective paires (f, set) where f is a polynomial and set is a string\n\n\"inf\", \"sup\" to define the objective.\n\"=0\" to define zero constraints:\n\">=0\", \"<=0\" to define sign constraints\n\nIt outputs\n\nv: the optimal value\nM: the optimized moment program of type MOM.Model\n\nExample\n\nusing MomentPolynomialOpt, DynamicPolynomials\n\nX  = @polyvar x1 x2\ne1 = x1^2-2\ne2 = (x2^2-3)*(x1*x2-2)\np1 = x1\np2 = 2-x2\nv, M = optimize([(-x1, \"inf\"), (e1, \"=0\"), (e2, \"=0\"), (p1, \">=0\"), (p2>=0)], X, 3)\n\nTo recover the optimal values, see get_minimizers, get_measure, get_series.\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#MomentPolynomialOpt.get_minimizers","page":"Moment Optimization Programs","title":"MomentPolynomialOpt.get_minimizers","text":"get_minimizers(M, , t::Int64 = Inf)\n\nReturn the minimizer points  of the optimized moment program M, using moments of degree <=t (default: twice the order of the relaxation minus 2)\n\nget_minimizer(M)\n\n[1.41421 1.73205; 1.41421 1.41421; 1.41421 -1.73205]\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#MomentPolynomialOpt.get_measure","page":"Moment Optimization Programs","title":"MomentPolynomialOpt.get_measure","text":"w, Xi = get_measure(M)\n\nReturn the approximation of the moment sequence mu truncated to moments of degree <= t (default: twice the order of the relaxation minus 2), as weighted sum of Dirac measures: sum_k=1^r omega_k delta_xi_k where\n\nw is the vector of weights of the Dirac measures.\nXi is matrix of ntimes r support points of the corresponding Dirac measures. The column Xi[:,i] is the support point xi_i of the ith Dirac measure and its weights is w[i].\n\nw, Xi = get_measure(M)\n\n([0.1541368146508854, 0.5889741915171074, 0.256888993597116], [1.4142135624216647 1.414213562080608 1.4142135620270329; -1.732052464639053 1.4141771454788292 1.7319839273833693])\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#MomentPolynomialOpt.get_series","page":"Moment Optimization Programs","title":"MomentPolynomialOpt.get_series","text":"get_series(M)\n\nReturn the vector of nu=M[:nu] series of optimal moments of the optimized moment program M.\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#MomentPolynomialOpt.annihilator","page":"Moment Optimization Programs","title":"MomentPolynomialOpt.annihilator","text":"K,I,P,B = annihilator(sigma::Series{R}, L, eqzero = is_zero)\n\nCompute a graded basis of the annihilator of the positive series σ in the space spanned by the list of monomials L.\n\nIt outputs:\n\nK the graded basis\nI the initial monomials of K\nP the orthogonal basis\nB the monomial basis\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#MomentPolynomialOpt.polar_minimize","page":"Moment Optimization Programs","title":"MomentPolynomialOpt.polar_minimize","text":"v, M = polar_minimize(f, [h1, h2, ...], [g1, g2, ...], X, degree_approx, optimizer)\n\nCompute the infimum of the f (equality constraints hi == 0 and the sign constraints gi >= 0) on the moment side. It does that calling minimize(...), replacing the equality constraints  [h1, h2, ...] with generators of the polar ideal.\n\nf, hi, gi should be polynomials in the variables X.\n\nIf the problem is feasible and has minimizers, it outputs\n\nv: the minimum value\nM: the moment model of type MOM.Model\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#MomentPolynomialOpt.polar_ideal","page":"Moment Optimization Programs","title":"MomentPolynomialOpt.polar_ideal","text":"j = polar_ideal(f, [h1, h2, ...], [g1, g2, ...], X)\n\nCompute generators of the polar ideal associated with f, [h1, h2, ...], [g1, g2, ...] (equality constraints hi == 0 and the sign constraints gi >= 0) with respect to the variable vector X.\n\nf, hi, gi should be polynomials in variables X.\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#MomentPolynomialOpt.preordering","page":"Moment Optimization Programs","title":"MomentPolynomialOpt.preordering","text":"pg = preordering([g1, g2, ...])\n\nCompute all the product, without repetitions, of the gi's i.e. computes the generators (as a quadratic module) of the preordering O(g1, g2, ...).\n\n\n\n\n\n","category":"function"},{"location":"code/2.optimization/#MomentPolynomialOpt.min_ellipsoid","page":"Moment Optimization Programs","title":"MomentPolynomialOpt.min_ellipsoid","text":"Compute the minimal ellipsoid enclosing the point P of the semi-algebraic set defined by H[j]=0, G[k]>=0\n\nIt outputs the center c and the matrix U which columns are the principal axes of the ellipsoid.\n\n\n\n\n\n","category":"function"},{"location":"expl/0.real_roots/#A-simple-univariate-example","page":"A simple univariate example","title":"A simple univariate example","text":"using DynamicPolynomials, MomentPolynomialOpt\n\nX = @polyvar x\np = x^4+x^3-x-1\n\n$ -1 - x + x^{3} + x^{4} $\n\nWe minimize x^2 under the constraint p=0. \n\nusing JuMP, MosekTools; mpo_optimizer(Mosek.Optimizer, \"QUIET\" => true)\nv, M = minimize(x^2, [p], [], X, 4)\n\n(0.9999999937113259, A JuMP Model\nMinimization problem with:\nVariables: 9\nObjective function type: VariableRef\n`AffExpr`-in-`MathOptInterface.EqualTo{Float64}`: 6 constraints\n`Vector{AffExpr}`-in-`MathOptInterface.PositiveSemidefiniteConeTriangle`: 1 constraint\nModel mode: AUTOMATIC\nCachingOptimizer state: ATTACHED_OPTIMIZER\nSolver name: Dual model with Mosek attached\nNames registered in the model: mu, type)\n\nWe use Mosek optimizer to solve the underlying SDP optimization problem. The first argument x^2 of the function minimize is the objective function. The second argument is the array of equality constraints, the third is the array of non-negativity constraints (here empty).\n\nThe function minimize returns v the optimal value found (here it is approx 1) and M the Moment Model built for the optimization (which type is MomentPolynomialOpt.MOM.Model). \n\nThe minimizers can be obtained from M as follows:\n\nget_minimizers(M)\n\n1×2 Matrix{Float64}:\n -1.0  1.0\n\nThe minimizers are presented as a ntimes r matrix, where n is the number of variables (here n=1) and r is the number of points (here r=2). \n\nAn approximation  of the associate measure can be obtained as follows:\n\nget_measure(M)\n\n([0.4781556356477239, 0.5218443598681404], [0.9999999995837139 -1.0000000010811763])\n\nIt corresponds approximately to the measure 05 delta_-1 + 05 delta_1 where delta_x is the Dirac measure supported on x.\n\nNext, we search the root(s) with x geq 0. For that purpose, we minimize nothing (i.e. 1) and add the non-negativity constraint xgeq 0:\n\nv, M = minimize(1, [p], [x], X, 4)\nget_minimizers(M)\n\n1×1 Matrix{Float64}:\n 1.0000000000608462\n\nNow we search the negative root with maximal value of x.\n\nv, M = maximize(x, [p], [-x], X, 4)\nget_minimizers(M)\n\n1×1 Matrix{Float64}:\n -0.9999999993829266\n\n","category":"section"}]
}
